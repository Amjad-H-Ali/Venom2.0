*** BACKUS-NAUR FORM ***

** PARSER **

<FUNCTION>             ::= [ (<PARAM_LIST>) | <IDENT> | () ] => [ <STATEMENT_BLOCK> | <STATEMENT> ]

<PARAM_LIST>           ::= <IDENT> | <DESTRUCT_ASSGN> | <IDENT> <PARAM_LIST> | <DESTRUCT_ASSGN> <PARAM_LIST>

<IDENT>                ::= <VAR>

<STATEMENT_BLOCK>      ::= { <STATEMENT_LIST> } | {}

<STATEMENT>            ::= <ASSGNMNT> | <IF> | <WHILE> | <FOR> | <DO> | <RETURN> | <INIT> | <DECL>

<ASSGNMNT>             ::= <L_VAL> = <R_VAL>

<DESTRUCT_ASSGN>       ::= { <DESTRUCT_ASSGN_LIST> } 
 
<DESTRUCT_ASSGN_LIST>  ::= <IDENT> | { <DESTRUCT_ASSGN_LIST> } | <IDENT> <DESTRUCT_ASSGN_LIST> | <DESTRUCT_ASSGN_LIST> <DESTRUCT_ASSGN_LIST> 

<STATEMENT_LIST>       ::= <STATEMENT> | <STATEMENT> <STATEMENT_LIST>

<IF>                   ::=   if ( <EXP> ) <STATEMENT_BLOCK> 
                           | if ( <EXP> ) <STATEMENT> 
                           | if ( <EXP> ) <STATEMENT_BLOCK> <ELIF>
                           | if ( <EXP> ) <STATEMENT> <ELIF>
                           | if ( <EXP> ) <STATEMENT_BLOCK> <ELSE>
                           | if ( <EXP> ) <STATEMENT> <ELSE>
                           | if ( <EXP> ) <STATEMENT_BLOCK> <ELIF> <ELSE>
                           | if ( <EXP> ) <STATEMENT> <ELIF> <ELSE>

<ELIF>                ::=    else if ( <EXP> ) <STATEMENT_BLOCK>
                           | else if ( <EXP> ) <STATEMENT>
                           | else if ( <EXP> ) <STATEMENT_BLOCK> <ELIF>
                           | else if ( <EXP> ) <STATEMENT> <ELIF>
                          
<ELSE>                ::= else <STATEMENT_BLOCK> | else <STATEMENT>

<WHILE>               ::= while ( <EXP> ) <STATEMENT_BLOCK> | while ( <EXP> ) <STATEMENT>

<FOR>                 ::= for ( <INIT> ; <EXP> ; <EXP> ) <STATEMENT_BLOCK> | for ( <INIT> ; <EXP> ; <EXP> ) <STATEMENT>

<DO>                  ::= do <STATEMENT_BLOCK> while ( <EXP> ) | do <STATEMENT> while ( <EXP> )

<RETURN>              ::= return <ASSGNMNT> | return <EXP>

<INIT>                ::= let <IDENT> = <R_VAL> | const let <IDENT> = <R_VAL>

<DECL>                ::= let <IDENT>

<L_VAL>               ::= <IDENT> | <DESTRUCT_ASSGN>

<R_VAL>               ::= <EXP> | <ASSGNMNT> | <FUNCTION> 

<EXP>                 ::= <EXP> + <TERM> | <EXP> - <TERM> | <TERM>

<TERM>                ::= <TERM> * <POWER> | <TERM> / <POWER> | <POWER>

<POWER>               ::= <FACTOR> ^ <POWER> | <FACTOR>

<FACTOR>              ::= ( <EXP> ) | <NUM> | <IDENT>

                           

